1、什么是进程？
    进程是正在运行的程序的实例（an instance of a computer program that is being executed)
    进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，
 进程即是基本的分配单元，也是基本的执行单元。
2、什么是线程？
    线程有时候被称为轻量级进程（lightweight process），是程序执行流的最小单元。一个标准的线程由线程id，当前指令指针pc，寄存器集合和堆栈组成。
 线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的
 其它线程共享进程所又拥有的全部资源。
3、进程和线程的区别？
    线程和进程的主要区别在于它们是不同的操作系统资源管理方式。
    进程有独立的地址空间，一个进程崩溃后，在保护模式先不会对其他进程产生影响，
    而线程知识一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有独立的地址空间，一个线程死掉了就等于整个进程死掉，
所以多进程的程序比多线程的程序健壮，但在进程切换时，耗费资源较大，效率较差。对于一些要求同时进行并且又要共享某些变量的并发操作，只能有线程，不能用进程。
    ①、一个程序至少有一个进程，一个进程至少有一个线程；
    ②、线程的划分尺度小于进程，使得多线程程序的并发性高；
    ③、进程在执行过程中拥有独立的内存单元，而多线程共享内存，从而极大地提高了程序的运行效率；
    ④、线程在执行工程中与进程是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能独立执行，必须依存在应用程序中，有应用程序提供多个线程执行控制；
    ⑤、从逻辑的角度看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没将多个线程看作多个独立的应用，来实现进程的调度和管理以及资源分配。
4、线程的生命周期
    ①、新建状态（new）：当线程对象被创建后，即进入了新建状态；Thread thread = new MyThread();
    ②、就绪状态（runnable）：当调用线程对象的start()方法（thread.start();）。线程即进入就绪状态，处于就绪状态的线程，只是说明次线程已经做好了准备，随时等待CPU调度，并不是说执行了thread.start()线程就立即开始执行。
    ③、运行状态（running）：当CPU开始调度处于就绪状的线程时，此时线程得以真正执行，即进入运行状态。就绪状态是进入运行状态的唯一入口。
    ④、阻塞状态（blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态。阻塞状态的线程需要先进入就绪状态才有机会再次被CPU调用以进入运行状态。
        等待阻塞：运行状态中的线程执行wait()方法，该线程进入等待阻塞状态
        同步阻塞：线程在获取synchronized同步锁失败（因为锁被其它线程占用），该线程进入同步阻塞状态
        其它阻塞：通过调用线程的sleep()或join()或发出了I/O请求是，线程会进入阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
    ⑤、死亡状态（dead）：线程执行完了或者异常突出了run()方法，该线程结束生命周期

5、线程调用start()方法的过程
    ①、启动新的执行线程，分配了新的调用栈
    ②、该线程从新状态转移到可运行状态
    ③、当该线程获得新机会执行时，其目标run()方法将运行


三种方式实现线程
1、线程主体类继承Thread类
2、线程主体类继承Runnable接口
3、线程主体类继承Callable接口

Thread类和Runnable接口实现多线程两种方式的联系与区别？
联系：多线程的两种实现方式都需要一个线程的主类，这个类可以实现Runnable接口或者Thread类，但不管使用何种方式都必须在子类之中重写run()方法，因为run()方法为线程的主方法。
区别：①Thread类时Runnable接口的子类，使用Runnable接口实现多线程可以避免单继承的局限性，
      ②Runnable接口实现的多线程可以比Thread类实现的多线程更加清楚的描述数据共享的概念。代码能够被多个线程共享，代码与数据是独立的。

多线程常用的方法：
1、 currentThread()方法：返回代码段正在被哪个线程调用的信息。
2、 setName()/getName()方法和 getId()方法：
    （1） setName()/getName()方法：设置/取得线程的名称；
    （2） getId()方法：取得线程的唯一标识。
3、 setPriority（int p） /getPriority()方法
    （1） setPriority（int p）方法：设置优先级
    （2） getPriority()方法：获取优先级
    优先级常量：
    最高优先级： MAX_PRIORITY：public static final int MAX_PRIORITY = 10;
    默认优先级： NORM_PRIORITY：public static final int NORM_PRIORITY = 5;
    最低优先级： MIN_PRIORITY：public static final int MIN_PRIORITY = 1;
4、 sleep（）方法：在指定的毫秒数内，让“正在执行的线程” 休眠（暂停执行），这里“正在执行的线程”是指this.currentThread()


线程的同步与死锁
1、线程同步问题的引出
    所谓的同步问题指的是多个线程操作同一资源时所带来的安全性问题。
2、线程同步问题的解决
    同步，就是指多个操作在同一个时间段内只能有一个线程进行，其他线程要等这个线程执行完成才可以继续执行。
    方式一：同步代码块，使用 synchronized 关键字定义的代码块就称为同步代码块。
    同步代码块格式：
    synchronized(同步对象){//在进行同步的操作时必须设置一个要同步的对象，而这个对象应该理解为当前对象： this。
    需要同步的代码
    }
    方式二：同步方法。除了可以将需要的代码设置成同步代码块之外，也可以使用 synchronized 关键字将一个方法声明成同步方法。定义格式：
    synchronized 方法返回值 方法名称(参数列表){ }
同步操作与异步操作相比，异步操作的速度要明显高于同步操作，但同步操作是数据的安全性较高，属于安全的线程操作
3、死锁
    指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

    产生死锁的原因？
    （1）因为系统资源不足。
    （2）进程运行推进的顺序不合适
    （3）资源分配不当

    操作系统中，产生死锁的条件有四个：
    （1）互斥条件：所谓互斥就是进程在某一时间内独占资源。
    （2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
    （3）不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。
    （4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

    如何解决死锁？
    可以从死锁的四个条件出发去解决，只要破坏一个必要条件，那么我们的死锁就解决了。
    在 Java 中使用多线程的时候一定要考虑是否有死锁的问题。

解释 sleep()和 wait()的区别？
    （1） sleep()是 Thread 类定义的方法，而 wait()方法时 Object 定义的方法；
    （2） sleep()可以设置休眠时间，时间一到自动唤醒，而 wait()方法需要使用notify()方法进行唤醒。
